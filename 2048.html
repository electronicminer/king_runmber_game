<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2048 游戏</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap');
        
        body {
            font-family: 'Noto Sans SC', sans-serif;
            touch-action: none; /* 防止移动端滑动屏幕 */
            -webkit-user-select: none;
            user-select: none;
        }

        /* 动画定义 */
        @keyframes pop-in {
            0% { opacity: 0; transform: scale(0.5); }
            100% { opacity: 1; transform: scale(1); }
        }
        
        @keyframes fade-in {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }

        .animate-pop-in {
            animation: pop-in 0.2s ease-out backwards;
        }

        .animate-fade-in {
            animation: fade-in 0.8s ease-in forwards;
        }

        .animate-bounce-custom {
            animation: bounce 1s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(-25%); animation-timing-function: cubic-bezier(0.8,0,1,1); }
            50% { transform: translateY(0); animation-timing-function: cubic-bezier(0,0,0.2,1); }
        }
    </style>
</head>
<body class="min-h-screen bg-[#faf8ef] flex flex-col items-center justify-center p-4">

    <!-- 头部信息 -->
    <div class="w-full max-w-[500px] flex justify-between items-center mb-6">
        <div>
            <h1 class="text-6xl font-bold text-[#776e65]">2048</h1>
            <p class="text-[#776e65] mt-2 text-sm font-medium">合并数字直到达到 2048!</p>
        </div>
        
        <div class="flex gap-2">
            <div class="bg-[#bbada0] rounded-md p-2 min-w-[80px] text-center text-white">
                <div class="text-xs uppercase font-bold tracking-wide text-[#eee4da]">得分</div>
                <div id="score-display" class="text-xl font-bold">0</div>
            </div>
            <div class="bg-[#bbada0] rounded-md p-2 min-w-[80px] text-center text-white relative">
                <div class="text-xs uppercase font-bold tracking-wide text-[#eee4da]">最高分</div>
                <div id="best-score-display" class="text-xl font-bold">0</div>
                <!-- 破纪录奖杯图标 -->
                <div id="new-record-icon" class="hidden absolute -top-3 -right-3 w-6 h-6 text-yellow-500 fill-current animate-bounce-custom">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg>
                </div>
            </div>
        </div>
    </div>

    <!-- 控制栏 -->
    <div class="w-full max-w-[500px] flex justify-between items-center mb-6">
         <div class="text-[#776e65] flex items-center gap-2 text-sm sm:text-base">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
            <span class="hidden sm:inline">使用方向键或滑动屏幕来移动</span>
            <span class="sm:hidden">滑动屏幕移动</span>
         </div>
         <button id="new-game-btn" class="bg-[#8f7a66] hover:bg-[#806d5b] text-white font-bold py-2 px-4 rounded flex items-center gap-2 transition-colors cursor-pointer">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 12"/><path d="M3 3v9h9"/></svg> 
            新游戏
        </button>
    </div>

    <!-- 游戏区域 -->
    <div class="relative bg-[#bbada0] rounded-lg p-3 touch-none select-none shadow-lg w-full max-w-[500px] aspect-square">
        <!-- 背景网格 -->
        <div class="grid grid-cols-4 gap-3 w-full h-full">
            <div class="bg-[#cdc1b4] rounded-md"></div>
            <div class="bg-[#cdc1b4] rounded-md"></div>
            <div class="bg-[#cdc1b4] rounded-md"></div>
            <div class="bg-[#cdc1b4] rounded-md"></div>
            <div class="bg-[#cdc1b4] rounded-md"></div>
            <div class="bg-[#cdc1b4] rounded-md"></div>
            <div class="bg-[#cdc1b4] rounded-md"></div>
            <div class="bg-[#cdc1b4] rounded-md"></div>
            <div class="bg-[#cdc1b4] rounded-md"></div>
            <div class="bg-[#cdc1b4] rounded-md"></div>
            <div class="bg-[#cdc1b4] rounded-md"></div>
            <div class="bg-[#cdc1b4] rounded-md"></div>
            <div class="bg-[#cdc1b4] rounded-md"></div>
            <div class="bg-[#cdc1b4] rounded-md"></div>
            <div class="bg-[#cdc1b4] rounded-md"></div>
            <div class="bg-[#cdc1b4] rounded-md"></div>
        </div>

        <!-- 实际方块层 -->
        <div id="tile-container" class="absolute top-3 left-3 right-3 bottom-3 grid grid-cols-4 gap-3">
            <!-- JavaScript 将在这里动态生成方块 -->
        </div>

        <!-- 游戏结束/胜利 遮罩 -->
        <div id="game-overlay" class="hidden absolute inset-0 z-20 flex-col items-center justify-center bg-[rgba(238,228,218,0.73)] rounded-lg animate-fade-in">
            <h2 id="overlay-message" class="text-6xl font-bold text-[#776e65] mb-4">游戏结束!</h2>
            <div class="flex gap-4">
                <button id="keep-playing-btn" class="hidden bg-transparent border-2 border-[#8f7a66] text-[#8f7a66] font-bold py-3 px-6 rounded hover:bg-[#8f7a66] hover:text-white transition-colors cursor-pointer">
                    继续挑战
                </button>
                <button id="try-again-btn" class="bg-[#8f7a66] text-white font-bold py-3 px-6 rounded shadow-lg hover:bg-[#806d5b] transition-transform active:scale-95 cursor-pointer">
                    再来一局
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- 常量与状态 ---
        const GRID_SIZE = 4;
        let grid = [];
        let score = 0;
        let bestScore = 0;
        let gameOver = false;
        let gameWon = false;
        let isWonAndContinued = false; // 是否在赢了之后选择继续
        let animating = false;

        // --- DOM 元素 ---
        const tileContainer = document.getElementById('tile-container');
        const scoreDisplay = document.getElementById('score-display');
        const bestScoreDisplay = document.getElementById('best-score-display');
        const newRecordIcon = document.getElementById('new-record-icon');
        const overlay = document.getElementById('game-overlay');
        const overlayMessage = document.getElementById('overlay-message');
        const keepPlayingBtn = document.getElementById('keep-playing-btn');
        const tryAgainBtn = document.getElementById('try-again-btn');
        const newGameBtn = document.getElementById('new-game-btn');

        // --- 初始化 ---
        function init() {
            const savedBest = localStorage.getItem('2048-best-score-html');
            if (savedBest) {
                bestScore = parseInt(savedBest, 10);
            }
            updateBestScoreDisplay();
            startNewGame();
            
            // 事件监听
            window.addEventListener('keydown', handleKeyDown);
            newGameBtn.addEventListener('click', startNewGame);
            tryAgainBtn.addEventListener('click', startNewGame);
            keepPlayingBtn.addEventListener('click', continueGame);
            
            // 触摸事件
            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { passive: false });
        }

        // --- 游戏逻辑 ---

        function getEmptyGrid() {
            return Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
        }

        function addRandomTile(currentGrid) {
            const emptyCells = [];
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (currentGrid[r][c] === 0) {
                        emptyCells.push({ r, c });
                    }
                }
            }

            if (emptyCells.length === 0) return currentGrid;

            const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
            currentGrid[randomCell.r][randomCell.c] = Math.random() < 0.9 ? 2 : 4;
            return currentGrid;
        }

        function startNewGame() {
            grid = getEmptyGrid();
            grid = addRandomTile(grid);
            grid = addRandomTile(grid);
            score = 0;
            gameOver = false;
            gameWon = false;
            isWonAndContinued = false;
            
            updateView();
            hideOverlay();
        }

        function continueGame() {
            isWonAndContinued = true;
            hideOverlay();
        }

        function checkGameOver() {
            // 检查空位
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (grid[r][c] === 0) return false;
                }
            }
            // 检查合并
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (c < GRID_SIZE - 1 && grid[r][c] === grid[r][c + 1]) return false;
                    if (r < GRID_SIZE - 1 && grid[r][c] === grid[r + 1][c]) return false;
                }
            }
            return true;
        }

        // --- 视图更新 ---

        function getTileClasses(value) {
            const baseClasses = "w-full h-full rounded-md flex justify-center items-center font-bold transition-all duration-200 ease-in-out transform scale-100 animate-pop-in";
            let colorClasses = 'bg-[#3c3a32] text-white'; // 默认
            let textSize = 'text-xl md:text-2xl'; // 默认大数字

            // 颜色映射
            const colors = {
                2: 'bg-[#eee4da] text-[#776e65]',
                4: 'bg-[#ede0c8] text-[#776e65]',
                8: 'bg-[#f2b179] text-white',
                16: 'bg-[#f59563] text-white',
                32: 'bg-[#f67c5f] text-white',
                64: 'bg-[#f65e3b] text-white',
                128: 'bg-[#edcf72] text-white shadow-[0_0_30px_10px_rgba(243,215,116,0.23)]',
                256: 'bg-[#edcc61] text-white shadow-[0_0_30px_10px_rgba(243,215,116,0.31)]',
                512: 'bg-[#edc850] text-white shadow-[0_0_30px_10px_rgba(243,215,116,0.39)]',
                1024: 'bg-[#edc53f] text-white shadow-[0_0_30px_10px_rgba(243,215,116,0.47)]',
                2048: 'bg-[#edc22e] text-white shadow-[0_0_30px_10px_rgba(243,215,116,0.55)]',
            };
            
            if (colors[value]) colorClasses = colors[value];

            // 字体大小
            if (value < 100) textSize = 'text-3xl md:text-4xl';
            else if (value < 1000) textSize = 'text-2xl md:text-3xl';

            return `${baseClasses} ${colorClasses} ${textSize}`;
        }

        function updateView() {
            // 更新分数
            scoreDisplay.textContent = score;
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('2048-best-score-html', bestScore);
                updateBestScoreDisplay();
            }

            // 渲染网格
            tileContainer.innerHTML = ''; // 清空
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cellWrapper = document.createElement('div');
                    cellWrapper.className = 'w-full h-full flex justify-center items-center'; // 占位符容器
                    
                    const val = grid[r][c];
                    if (val !== 0) {
                        const tile = document.createElement('div');
                        tile.className = getTileClasses(val);
                        tile.textContent = val;
                        cellWrapper.appendChild(tile);
                    }
                    tileContainer.appendChild(cellWrapper);
                }
            }

            // 检查状态
            if (gameWon && !isWonAndContinued) {
                showOverlay('你赢了!', true);
            } else if (gameOver) {
                showOverlay('游戏结束!', false);
            }
        }

        function updateBestScoreDisplay() {
            bestScoreDisplay.textContent = bestScore;
            // 只有当分数大于0且是最高分时显示图标
            if (score > 0 && score >= bestScore) {
                newRecordIcon.classList.remove('hidden');
            } else {
                newRecordIcon.classList.add('hidden');
            }
        }

        function showOverlay(message, isWin) {
            overlayMessage.textContent = message;
            overlay.classList.remove('hidden');
            overlay.classList.add('flex');
            
            if (isWin) {
                keepPlayingBtn.classList.remove('hidden');
            } else {
                keepPlayingBtn.classList.add('hidden');
            }
        }

        function hideOverlay() {
            overlay.classList.add('hidden');
            overlay.classList.remove('flex');
        }

        // --- 核心移动逻辑 (矩阵变换) ---

        function rotateGrid(matrix) {
            return matrix[0].map((val, index) => matrix.map(row => row[index]).reverse());
        }

        function rotateClockwise(matrix, times) {
            let temp = matrix;
            for (let i = 0; i < times; i++) {
                temp = rotateGrid(temp);
            }
            return temp;
        }

        function move(direction) {
            if (gameOver || (gameWon && !isWonAndContinued) || animating) return;

            animating = true;
            setTimeout(() => { animating = false; }, 100);

            let rotatedGrid = JSON.parse(JSON.stringify(grid));
            let scoreToAdd = 0;
            let moved = false;
            let hasWonThisMove = false;

            // 统一转换为向左移动逻辑
            let rotations = 0;
            if (direction === 'up') rotations = 3;
            if (direction === 'right') rotations = 2;
            if (direction === 'down') rotations = 1;

            let workingGrid = rotateClockwise(rotatedGrid, rotations);

            // 合并逻辑
            const newGridData = workingGrid.map(row => {
                let filtered = row.filter(val => val !== 0);
                for (let i = 0; i < filtered.length - 1; i++) {
                    if (filtered[i] === filtered[i + 1]) {
                        filtered[i] *= 2;
                        scoreToAdd += filtered[i];
                        if (filtered[i] === 2048) hasWonThisMove = true;
                        filtered.splice(i + 1, 1);
                    }
                }
                while (filtered.length < GRID_SIZE) {
                    filtered.push(0);
                }
                return filtered;
            });

            // 检查是否有变动
            if (JSON.stringify(workingGrid) !== JSON.stringify(newGridData)) {
                moved = true;
            }

            // 还原旋转
            const rotationsBack = (4 - rotations) % 4;
            let finalGrid = rotateClockwise(newGridData, rotationsBack);

            if (moved) {
                grid = addRandomTile(finalGrid);
                score += scoreToAdd;
                
                if (hasWonThisMove && !gameWon) {
                    gameWon = true;
                }

                if (checkGameOver()) {
                    gameOver = true;
                }
                
                updateView();
            }
        }

        // --- 输入处理 ---

        function handleKeyDown(e) {
            if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
            
            switch (e.key) {
                case 'ArrowUp': move('up'); break;
                case 'ArrowDown': move('down'); break;
                case 'ArrowLeft': move('left'); break;
                case 'ArrowRight': move('right'); break;
            }
        }

        // 触摸处理
        let touchStartX = 0;
        let touchStartY = 0;

        function handleTouchStart(e) {
            if (e.target.closest('button')) return; // 让按钮可点击
            // e.preventDefault(); // Chrome 处理 passive event listener 警告，此处使用 passive: false 解决
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }

        function handleTouchEnd(e) {
            if (e.target.closest('button')) return;
            // e.preventDefault();
            
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);

            if (Math.max(absDx, absDy) > 30) { // 阈值
                if (absDx > absDy) {
                    move(dx > 0 ? 'right' : 'left');
                } else {
                    move(dy > 0 ? 'down' : 'up');
                }
            }
        }

        // 启动
        init();

    </script>
</body>
</html>
